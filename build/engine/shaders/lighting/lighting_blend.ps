
/*
lighting_blend.ps
Cмешивание всех текстур для финального изображения
*/

#include <struct.h>
#include <mtrl.h>

//##########################################################################

Texture2D g_txColor: register(t0);
Texture2D g_txAmbient: register(t1);
SamplerState g_sPointClamp: register(s0);

// sampler2D g_sColor:register(s0);
// sampler2D g_sAmbient:register(s1);
// sampler2D g_sSpecDiff:register(s2);
// sampler2D g_sNormals:register(s3);
// sampler2D g_sAdaptedLum:register(s4);
// sampler2D g_sParameters:register(s5);

//##########################################################################

float4 main(VSO_PP IN):COLOR0
{
	float4 vColor = g_txAmbient.Sample(g_sPointClamp, IN.vTexUV);
	
	float fAdaptedLum = 0.2f;
	
	vColor.rgb *= TONE_MAPPING_DENOMENATOR/(fAdaptedLum + TONE_MAPPING_ADAPT_ADD_BIAS);
	vColor.rgb /= (fAdaptedLum + vColor.rgb);
	
	// return float4(pow(vColor.rgb, 1.0/2.2), vColor.a);
	return float4(vColor.rgb, vColor.a);
	
#if 0
	float4 vNormal = tex2D(g_sNormals,IN.vTexUV);
	float2 vLayerType = LayerDecode(vNormal.w);
	//vLayerType.x *= LAYERS_COUNT_MAX;
	//return half4(vLayerType.x, vLayerType.x, vLayerType.x, 1);
	//half fSort = LayerDecodeType(vNormal.w);
	//half fLayer = LayerDecodeLayer(vNormal.w);
	
	//цвет приводим к sRGB
	float4 vColor = tex2D(g_sColor,IN.vTexUV);
	vColor.rgb = pow(vColor.rgb, 2.2);
	float4 vParameters = tex2D(g_sParameters,IN.vTexUV);

	float4 vAmbient = tex2D(g_sAmbient,IN.vTexUV);
	//vAmbient.xyz *= 2;
	float fAverage = (vAmbient.x + vAmbient.y + vAmbient.z)/3.0;
	
	/* расчет фонового цвета
	1) интерполяция от чернобелого до цветного, на основании затенения, то есть чем больше тень тем меньше там фонового цвета
	*/
	float3 vAmbientColor = lerp(fAverage, vAmbient.xyz, saturate(vAmbient.w+0.5));
	
	/* 2) интерполяция приема цвета материалом, чем больше отражательная способность (f0) тем меньше примет цвета материал*/
	//vAmbientColor = lerp(vAmbientColor.xyz, fAverage, clamp(vParameters.y, F0_MIN_4_DEST_AMBIENT, F0_MAX_4_DEST_AMBIENT));
	
	float fSpecular = tex2D(g_sSpecDiff,IN.vTexUV).r;
	float fAdaptedLum = tex2D(g_sAdaptedLum, g_vTexUVcenter);

	// если материал освещаемый то надо вычислить его освещенность
	if(vLayerType.y == MTLTYPE_LIGHT)
		vColor.xyz = (vAmbientColor * vAmbient.w * vColor.xyz) + (fSpecular * 0.5 * vAmbient.xyz);
		
	// если слой материала относится к непрозрачной геометрии, тогда не нужна прозрачность
	if(vLayerType.x == LAYER_OPAQUE)
		vColor.a = 1.0;

	//применение тонмапинга
	vColor.rgb *= TONE_MAPPING_DENOMENATOR/(fAdaptedLum + TONE_MAPPING_ADAPT_ADD_BIAS);
	vColor.rgb /= (fAdaptedLum + vColor.rgb);
	
	//приводим цвет к линейному пространству
	return float4(pow(vColor.rgb, 1.0/2.2), vColor.a);
#endif
}
