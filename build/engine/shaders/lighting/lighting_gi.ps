
/*
lighting_gi.ps

*/

#include <lpv.h>
#include <struct.h>
#include <mtrl.h>

//##########################################################################

cbuffer perFrame: register(b1)
{
	float3 g_vViewPos;
};

//##########################################################################

SamplerState g_sPointClamp: register(s0);
SamplerState g_sLinearClamp: register(s1);

Texture2D g_txDepth:register(t0);
Texture2D g_txNormals:register(t1);
Texture3D g_txLightVolumeRed[3]:register(t2);
Texture3D g_txLightVolumeGreen[3]:register(t5);
Texture3D g_txLightVolumeBlue[3]:register(t8);

//#############################################################################

PSO_Lbuffer main(VSO_ResPos IN)
{
	PSO_Lbuffer OUT;

	float4 vNormals = g_txNormals.Sample(g_sPointClamp, IN.vTexUV);
	float fDepth = g_txDepth.Sample(g_sPointClamp,IN.vTexUV).r;
	
	float3 vOrigin = float3(0, 0, 0); // Центр сетки
	float4 vPosition = float4(g_vViewPos.xyz + IN.vWorldRay * fDepth, 1.0); // Мировая позиция пиксела
	
	float3 vNormalPixel = normalize(NormalDecode(vNormals.xyz).xyz);
	
	
	// float3 vNormalPixel = normalize(IN.vNormal);
	float4 SHintensity = dirToSH(-vNormalPixel);
	
	float r = 0.0f;
	float g = 0.0f;
	float b = 0.0f;

	for(uint i = 0; i < 3; ++i)
	{
		float3 vTexCoord = GetGridTexCoord(vPosition.xyz, i);
		float4 vColorR = g_txLightVolumeRed[i].Sample(g_sLinearClamp, vTexCoord);
		float4 vColorG = g_txLightVolumeGreen[i].Sample(g_sLinearClamp, vTexCoord);
		float4 vColorB = g_txLightVolumeBlue[i].Sample(g_sLinearClamp, vTexCoord);
		
		r += saturate(dot(SHintensity, vColorR));
		g += saturate(dot(SHintensity, vColorG));
		b += saturate(dot(SHintensity, vColorB));
	}
	
	
	
	OUT.vAmdient.xyz = float3(r, g, b) / PI/*  * 6.0f */;
	OUT.vAmdient.w = 1;
	OUT.vSpecular = 0;
	
	return OUT;
}





















