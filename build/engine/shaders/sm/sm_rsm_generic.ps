
/*
sm_depth_geom_pssm_direct.ps
Рендер глубины сцены (геометрии) с позиции позиции направленного/глобального источника света
*/

#include "../struct.h"
#include "../shadow.h"
#include "../mtrl.h"

//##########################################################################

SamplerState g_sScene: register(s0);
Texture2D g_txColor: register(t0);		// basetexture

/* cbuffer perLight: register(b5)
{
	float4 g_vLightColorPower;
	float4 g_vLightPosShadow;
#ifdef IS_SPOT
	float4 g_vLightSpotDirection;
	float2 g_vLightSpotInnerOuterAngles;
#endif
}; */

//##########################################################################

PSO_RSMbuffer main(VSO_SceneCommon IN)
{
	PSO_RSMbuffer OUT;
	
	float4 vColor = g_txColor.Sample(g_sScene, IN.vTexUV);
	
	ShadowDepthAlphaTest(vColor);
	
#ifdef IS_CUBEMAP
	// OUT.vDepth = dot(float3(-0.13445021, -0.55678467, -0.0801237256), float3(-0.13445021, -0.55678467, -0.0801237256))/*  / (g_vLightColorPower.w * g_vLightColorPower.w) */;
	OUT.vDepth = dot(IN.vPos.xyz, IN.vPos.xyz)/*  / (g_vLightColorPower.w * g_vLightColorPower.w) */;
	// OUT.vDepth = 2 * 2/*  / (g_vLightColorPower.w * g_vLightColorPower.w) */;
	// OUT.vDepth = 0.3345058;
#else
	float fDepth = IN.vPos.z / IN.vPos.w;
	float fBias = ShadowSlopeBias(fDepth);
	OUT.vDepth = fDepth/*  + fBias */;
#endif
	
	
/* 	float fAttenuation = 1.0;
#ifdef IS_SPOT
	float3 vLigth = normalize(g_vLightPosShadow.xyz - IN.vPos.xyz); 
	float fNdotD = dot(-vLigth, g_vLightSpotDirection.xyz);
	fAttenuation *= saturate(fNdotD - g_vLightSpotInnerOuterAngles.y) / (g_vLightSpotInnerOuterAngles.x - g_vLightSpotInnerOuterAngles.y);
#endif */
	
	OUT.vNormal = float4(NormalEncode(normalize(IN.vNormal)), 1.0);
	OUT.vFlux = vColor/*  * float4(g_vLightColorPower.xyz, 1.0) * fAttenuation */;
	
	return(OUT);
}
