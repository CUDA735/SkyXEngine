
/*
sm_depth_geom_pssm_direct.ps
Рендер глубины сцены (геометрии) с позиции позиции направленного/глобального источника света
*/

#include "../struct.h"
#include "../shadow.h"
#include "../mtrl.h"

//##########################################################################

SamplerState g_sScene: register(s0);
Texture2D g_txColor: register(t0);		// basetexture

/*cbuffer perLight: register(b5)
{
	half4 g_vLightColorPower;
	half4 g_vLightPosShadow;
#ifdef IS_SPOT
	half4 g_vLightSpotDirection;
	half2 g_vLightSpotInnerOuterAngles;
#endif
};*/

//##########################################################################

PSO_RSMbuffer main(VSO_SceneCommon IN)
{
	PSO_RSMbuffer OUT;
	
	half4 vColor = g_txColor.Sample(g_sScene, IN.vTexUV);
	
	ShadowDepthAlphaTest(vColor);
	
#ifdef IS_CUBEMAP
	OUT.vDepth = dot(IN.vPos, IN.vPos);
	// OUT.vDepth = length(IN.vPos);
#else
	half fDepth = IN.vPos.z / IN.vPos.w;
	half fBias = ShadowSlopeBias(fDepth);
	OUT.vDepth = fDepth + fBias;
#endif
	
	
/* 	half fAttenuation = 1.0;
#ifdef IS_SPOT
	half3 vLigth = normalize(g_vLightPosShadow.xyz - IN.vPos.xyz); 
	half fNdotD = dot(-vLigth, g_vLightSpotDirection.xyz);
	fAttenuation *= saturate(fNdotD - g_vLightSpotInnerOuterAngles.y) / (g_vLightSpotInnerOuterAngles.x - g_vLightSpotInnerOuterAngles.y);
#endif */
	
	OUT.vNormal = half4(NormalEncode(normalize(IN.vNormal)), 1.0);
	OUT.vFlux = vColor/*  * half4(g_vLightColorPower.xyz, 1.0) * fAttenuation */;
	
	return(OUT);
}
