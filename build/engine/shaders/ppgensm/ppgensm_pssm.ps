
/*
ppgensm_pssm.ps
Генерация теней для глобального света
*/

#include <../struct.h>
#include <../shadow.h>
#include <../mtrl.h>
#include <../ps.h>

//##########################################################################

//! позиция наблюдателя
half3 g_vPosCam;

//! дистанции до концов каждого сплита
half4 g_vDistSplit;

//! ближняя и дальняя плоскости
half2 g_vNearFar;

//! размеры пикселей
half2 g_vPixelSize;

half4x4 g_aMatrixTexture[5];

//! позиция пикселя в пространстве света
static half4 g_vTexCoord[5];

//! смещение глубины для каждого сплита
static half g_aBias[4] = {0.00001, 0.00009, 0.0003, 0.001};

//##########################################################################

sampler2D g_sDepthView:register(s0);
sampler2D g_sNormals:register(s6);

texture2D g_sDepthShadow0:register(s1);
texture2D g_sDepthShadow1:register(s2);
texture2D g_sDepthShadow2:register(s3);
texture2D g_sDepthShadow3:register(s4);
texture2D g_sDepthShadow4:register(s5);

sampler2D g_aDepthShadow[5] = 
{
	sampler_state{Texture = <g_sDepthShadow0>;}, 
	sampler_state{Texture = <g_sDepthShadow1>;},
	sampler_state{Texture = <g_sDepthShadow2>;}, 
	sampler_state{Texture = <g_sDepthShadow3>;},
	sampler_state{Texture = <g_sDepthShadow4>;}
};

//##########################################################################

//! считает есть ли тень для данного сплита текущего пикселя
half GetShadow(int iSplit)
{
	half fShadow = 0.0;
	half2 vTexUV = half2(0,0);
	half fDepth;
	
	[unroll]for(int x=-1; x<=1; x++)
	{
		[unroll]for(int y=-1; y<=1; y++)
		{
			vTexUV = g_vTexCoord[iSplit].xy + half2(x * g_vPixelSize.x, y * g_vPixelSize.y);
			fDepth = tex2Dlod2(g_aDepthShadow[iSplit], vTexUV, 0).r; 

			fShadow += ShadowCalcShading(fDepth, g_vTexCoord[iSplit].z, g_aBias[iSplit]);
		}
	}

	return (fShadow / 9.0);
}

//##########################################################################

half4 main(VSO_ResPos IN):COLOR0
{
	half fShadow = 0.0;
	half fDepth = tex2Dlod(g_sDepthView, half4(IN.vTexUV,0,0)).r;
	
	half3 vNormal = Color2Normal(tex2Dlod(g_sNormals, half4(IN.vTexUV,0,0)).rgb);
	
	half4 vPosition = half4(g_vPosCam + IN.vWorldRay * fDepth, 1.0);
	vPosition.xyz = ShadowPosScopeBias(vPosition.xyz, vNormal);
	
	g_vTexCoord[0]	= mul(vPosition, g_aMatrixTexture[0]);
	g_vTexCoord[1]	= mul(vPosition, g_aMatrixTexture[1]);
	g_vTexCoord[2]	= mul(vPosition, g_aMatrixTexture[2]);
	
	#if	!defined(SPLITS3)
	g_vTexCoord[3]	= mul(vPosition, g_aMatrixTexture[3]);
	#endif
	
	g_vTexCoord[4]	= mul(vPosition, g_aMatrixTexture[4]);
	
	//тень от облаков
	half fShadowSky = 1.f - tex2Dlod2(g_aDepthShadow[4], g_vTexCoord[4].xy, 0).r;
	fShadowSky = fShadowSky * fShadowSky * fShadowSky;
	
	
	half fDistance = fDepth * g_vNearFar.y;
	
	//затухание теней
	half fAttenuation = 1.f;
	
	#ifdef SPLITS3
	fAttenuation = saturate(fDistance / g_vDistSplit[2]);
	#else
	fAttenuation = saturate(fDistance / g_vDistSplit[3]);
	#endif
	
	[branch]if(fDistance >= 0.0 && fDistance < g_vDistSplit[0])
		fShadow = GetShadow(0);
	else [branch]if(fDistance >= 0.0 && fDistance < g_vDistSplit[1])
		fShadow = GetShadow(1);
	else [branch]if(fDistance >= 0.0 && fDistance < g_vDistSplit[2])
		fShadow = GetShadow(2);
		
	#if	!defined(SPLITS3)
	else [branch]if(fDistance >= 0.0 && fDistance < g_vDistSplit[3])
		fShadow = GetShadow(3);
	#endif
	
	else
		fShadow = PSSM_SHADING_LAST;
			
	return saturate(fShadowSky*(fShadow * (1.f - fAttenuation)));
} 