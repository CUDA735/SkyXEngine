
/*
ppgensm_direct.ps
Генерация теней для локального направленного света
*/

#include <struct.h>
#include <shadow.h>
#include <mtrl.h>
#include <ps.h>

//##########################################################################

cbuffer perFrame: register(b1)
{
	float3 g_vPosCam;
};

cbuffer perShadow: register(b6)
{
	float4x4	g_mMatrixTexture;
	// half4 g_vPixelSize;
	// half3 g_vSizeMapBias;
	float3 vPixelMapSizeBias;
};

cbuffer perLight: register(b0)
{
	float4 g_vLightColorPower;
	float4 g_vLightPosShadow;
#ifdef IS_SPOT
	float4 g_vLightSpotDirection;
	float2 g_vLightSpotInnerOuterAngles;
#endif
};



//##########################################################################

SamplerState g_sPointClamp: register(s0);
// SamplerState g_sLinearClamp: register(s1);
SamplerComparisonState g_sComparisonLinearClamp: register(s1);
// SamplerState g_sPointWrap: register(s2);

Texture2D g_txDepthView: register(t0);
Texture2D g_txDepthShadow: register(t1);
Texture2D g_txRandom: register(t2);
Texture2D g_txNormals: register(t3);

//##########################################################################

float4 main(VSO_ResPos IN):COLOR0
{
	float fShadow = 0.0f;
	half3 vNormal = normalize(NormalDecode(g_txNormals.Sample(g_sPointClamp, IN.vTexUV).xyz).xyz);
	//g_txDepthView.Sample(g_sPointClamp, IN.vTexUV)
	//g_txDepthShadow.Sample(g_sLinearClamp, IN.vTexUV)
	
	float fDepth = g_txDepthView.Sample(g_sPointClamp, IN.vTexUV).r;
	float4 vPixelPos = float4(g_vPosCam + IN.vWorldRay * fDepth,1.f);
	float4 vTexCoord = mul(vPixelPos, g_mMatrixTexture);
	vTexCoord.xyz = vTexCoord.xyz / vTexCoord.w;
	
	[branch]if(!(vTexCoord.x <= 1.f && vTexCoord.y <= 1.f && vTexCoord.x >= 0.f && vTexCoord.y >= 0.f))
		clip(-1);
	
	// float fBias = vPixelMapSizeBias.z / vTexCoord.w;
	float cosTheta = saturate(dot(vNormal, normalize(g_vLightPosShadow.xyz - vPixelPos.xyz)));
	// float fBias = clamp(vPixelMapSizeBias.z * tan(acos(cosTheta)), 0,0.01) / vTexCoord.w;
	// float fBias = clamp(0.001f * tan(acos(cosTheta)), 0,0.001f) / vTexCoord.w;
	float fBias = clamp(0.0001f / (vPixelMapSizeBias.x * 0.0009765625) * tan(acos(cosTheta)), 0.0001,0.001f) / vTexCoord.w;
	// float fBias = 0.001f / vTexCoord.w;
	
// #undef GSD_9
	
	// fShadow += g_txDepthShadow.Sample(g_sLinearClamp, vTexCoord.xy).x >= vTexCoord.z ? 1 : 0;
	// fShadow += (g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy).x + 0.00001) >= vTexCoord.z ? 1 : 0;
	
	float fCompareTo = vTexCoord.z - fBias;
	
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy, fCompareTo);
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy + float2(0, vPixelMapSizeBias.x), fCompareTo);
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy + float2(vPixelMapSizeBias.x, 0), fCompareTo);
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy + float2(vPixelMapSizeBias.x, vPixelMapSizeBias.x), fCompareTo);
	#ifdef GSD_9
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy + float2(-vPixelMapSizeBias.x, 0), fCompareTo);
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy + float2(vPixelMapSizeBias.x, -vPixelMapSizeBias.x), fCompareTo);
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy + float2(-vPixelMapSizeBias.x, vPixelMapSizeBias.x), fCompareTo);
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy + float2(0, -vPixelMapSizeBias.x), fCompareTo);
	fShadow += g_txDepthShadow.SampleCmpLevelZero(g_sComparisonLinearClamp, vTexCoord.xy + float2(-vPixelMapSizeBias.x, -vPixelMapSizeBias.x), fCompareTo);

	fShadow *= 0.111;
	#else
	fShadow *= 0.25;
	#endif
	
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy).x, vTexCoord.z, fBias);
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy + half2(0, vPixelMapSizeBias.x)).x, vTexCoord.z, fBias);
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy + half2(vPixelMapSizeBias.x, 0)).x, vTexCoord.z, fBias);
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy + half2(vPixelMapSizeBias.x, vPixelMapSizeBias.x)).x, vTexCoord.z, fBias);

	// #ifdef GSD_9
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy + half2(-vPixelMapSizeBias.x, 0)).x, vTexCoord.z, fBias);
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy + half2(vPixelMapSizeBias.x, -vPixelMapSizeBias.x)).x, vTexCoord.z, fBias);
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy + half2(-vPixelMapSizeBias.x, vPixelMapSizeBias.x)).x, vTexCoord.z, fBias);
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy + half2(0, -vPixelMapSizeBias.x)).x, vTexCoord.z, fBias);
	// fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sPointClamp, vTexCoord.xy + half2(-vPixelMapSizeBias.x, -vPixelMapSizeBias.x)).x, vTexCoord.z, fBias);

	// fShadow *= 0.111;
	// #else
	// fShadow *= 0.25;
	// #endif

	return saturate(fShadow);
	// return float4(vNormal, 1);
} 