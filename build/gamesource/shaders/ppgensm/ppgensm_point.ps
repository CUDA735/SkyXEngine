
/*
ppgensm_point.ps
Генерация теней для локального точечного света
*/

#include <../struct.h>
#include <../shadow.h>
#include <../mtrl.h>
#include <../ps.h>

//##########################################################################

cbuffer perFrame: register(b1)
{
	half3 g_vPosCam;
};

cbuffer perShadow: register(b6)
{
	half2 g_vPixelSizeBias;
};

cbuffer perLight: register(b0)
{
	half4 g_vLightColorPower;
	half4 g_vLightPosShadow;
#ifdef IS_SPOT
	half4 g_vLightSpotDirection;
	half2 g_vLightSpotInnerOuterAngles;
#endif
};

//##########################################################################

// sampler2D g_sDepthView:register(s0);
// samplerCUBE g_sDepthShadow:register(s1);

SamplerState g_sPointClamp: register(s0);
SamplerState g_sLinearClamp: register(s1);
// SamplerState g_sPointWrap: register(s2);

Texture2D g_txDepthView: register(t0);
TextureCube g_txDepthShadow: register(t1);

// g_txDepthShadow.Sample(g_sLinearClamp, IN.vTexUV)

//##########################################################################

half4 main(VSO_ResPos IN):COLOR0
{
	half fShadow = 0.0;
	//g_vPixelSizeBias.y = -0.05;
	// half fDepth = tex2Dlod2(g_sDepthView, IN.vTexUV, 0).r;
	half fDepth = g_txDepthView.Sample(g_sPointClamp, IN.vTexUV).r;
	
	// return(1);
	
	half4 vPosition = half4(g_vPosCam + IN.vWorldRay * fDepth, 1.0);
	
	half3 vDir = g_vLightPosShadow.xyz - vPosition.xyz;
    half fDistance = dot(vDir, vDir);
	// half fDistance = length(vDir);
	half fDivDist = 1.0/fDistance;

	//vDir = normalize(vDir);
	half3 vTexUV = vDir.xyz;
	
	//fShadow = (texCUBE(g_sDepthShadow , -(vTexUV) * fDivDist ).x + g_vPixelSizeBias.y) > fDistance ? 1 : 0;
	fShadow = ShadowCalcShading(g_txDepthShadow.Sample(g_sLinearClamp, -(vTexUV) * fDivDist).x, fDistance, g_vPixelSizeBias.y);
	
	#ifdef GSC_6
	for(int x=0;x<=1;++x)
	{
		for(int y=0;y<=1;++y)
		{
			for(int z=0;z<=1;++z)
			{
				vTexUV = vDir + half3(g_vPixelSizeBias.x * x, g_vPixelSizeBias.x * y, g_vPixelSizeBias.x * z);
				//fShadow += texCUBE(g_sDepthShadow, -(vTexUV) * fDivDist).x + g_vPixelSizeBias.y < fDistance ? 0 : 1;
				fShadow += ShadowCalcShading(g_txDepthShadow.Sample(g_sLinearClamp, -(vTexUV) * fDivDist).x, fDistance, g_vPixelSizeBias.y);
			}
		}
	}
	
	fShadow *= 0.125;
	#endif

	return saturate(fShadow);
} 