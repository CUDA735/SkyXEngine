
/*
ppgensm_point.ps
Генерация теней для локального точечного света
*/

#include <../struct.h>
#include <../shadow.h>
#include <../mtrl.h>
#include <../ps.h>

//##########################################################################

half3 g_vPosCam;
half2 g_vSizeMapBias;
half g_fPixelSize;
half3 g_vLightPos;
half4x4	g_vMatrixTexture;

//##########################################################################

sampler2D g_sDepthView:register(s0);
samplerCUBE g_sDepthShadow:register(s1);

//##########################################################################

half4 main(VSO_ResPos IN):COLOR0
{
	half fShadow = 0.0;
	
	half fDepth = tex2Dlod2(g_sDepthView, IN.vTexUV, 0).r;
	
	half4 vPosition = half4(g_vPosCam + IN.vWorldRay * fDepth, 1.0);
	
	half3 vDir = g_vLightPos - vPosition.xyz;
    half fDistance = length(vDir);
	half fDivDist = 1.0/fDistance;

	half3 vTexUV = vDir.xyz;
	
	//fShadow = (texCUBE(g_sDepthShadow , -(vTexUV) * fDivDist ).x + g_vSizeMapBias.y) > fDistance ? 1 : 0;
	fShadow = ShadowCalcShading(texCUBE(g_sDepthShadow , -(vTexUV) * fDivDist).x, fDistance, g_vSizeMapBias.y);
	
	#ifdef GSC_6
	for(int x=0;x<=1;++x)
	{
		for(int y=0;y<=1;++y)
		{
			for(int z=0;z<=1;++z)
			{
				vTexUV = vDir + half3(g_fPixelSize * x, g_fPixelSize * y, g_fPixelSize * z);
				//fShadow += texCUBE(g_sDepthShadow, -(vTexUV) * fDivDist).x + g_vSizeMapBias.y < fDistance ? 0 : 1;
				fShadow += ShadowCalcShading(texCUBE(g_sDepthShadow , -(vTexUV) * fDivDist).x, fDistance, g_vSizeMapBias.y);
			}
		}
	}
	
	fShadow *= 0.125;
	#endif

	return saturate(fShadow);
} 