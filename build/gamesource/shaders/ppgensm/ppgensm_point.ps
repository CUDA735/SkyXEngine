
#include <../struct.h>
#include <../mtrl.h>

half3 PosCam;
half2 NearFar;
half2 SizeMapBias;
half PixelSize;
half3 LightPos;

sampler2D DepthLinearSampler:register(s0);
samplerCUBE DepthSampler1:register(s1);
sampler2D NoiseSampler:register(s2);

half4x4	MatrixTexture;

half4 main(vs_out_res_pos IN):COLOR0
{
	half ShadowTerm = 0.0f;
	
	half tmpdepth = GetDepthLinearR(tex2Dlod(DepthLinearSampler,half4(IN.TexUV,0,0)).r,NearFar);
	
	half4 Position = half4(PosCam + IN.WorldRay * (tmpdepth),1.f);
	
	half3 PLightDirection = 0.0f;
    PLightDirection = LightPos - Position.xyz;
    half distance = length(PLightDirection);
	half ddist = 1.f/distance;

	half3 jitter = half3(0,0,0);//(normalize(tex2D(NoiseSampler, -PLightDirection.xy*ddist * SHADOWGEN_JITTER_SCALE).xyz * 2.0 - 1.0 )*0.01);
	half3 tmpcoord = PLightDirection.xyz;
	tmpcoord.xyz += jitter;
	
	ShadowTerm = (texCUBE( DepthSampler1 , -(tmpcoord)*ddist ).x + SizeMapBias.y) > distance ? 1 : 0;
	
	#ifdef GSC_6
	for(int x=0;x<=1;++x)
	{
		for(int y=0;y<=1;++y)
		{
			for(int z=0;z<=1;++z)
			{
				tmpcoord = PLightDirection + half3(PixelSize*x, PixelSize*y,PixelSize*z) + jitter;
				ShadowTerm += texCUBE(DepthSampler1, -(tmpcoord)*ddist).x + SizeMapBias.y < distance ? 0 : 1;
			}
		}
	}
	
	ShadowTerm *= 0.125;
	#endif

	return saturate(ShadowTerm);
} 