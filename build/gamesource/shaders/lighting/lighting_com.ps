
/*
lighting_blend.ps
Расчет освещения и заполнение данными расчетов render targets
*/

#include <../struct.h>
#include <../mtrl.h>

//##########################################################################

half4 g_vLightPos;
half2 g_vLightPowerDist;
half4 g_vViewPos;
half4 g_vLightColor;

//##########################################################################

sampler2D g_sNormals:register(s1);
sampler2D g_sParameters:register(s2);
//x - шероховатость (roughness)
//y - отражательная способность поверхности (f0)
//z - толщина (thickness)
//w - occlusion

sampler2D g_sDepth:register(s3);
sampler2D g_sShadow:register(s4);
sampler2D g_sAdaptedLum:register(s5);

//#############################################################################

half D_Get(half roughness, half NdotH)
{
	half a = max(0.001f, roughness);
	half a2 = a*a;
	half d = ((NdotH * NdotH) * (a2 - 1.0) + 1.0);
	
	half NdotH2 = NdotH * NdotH;
	return ((1.0f/(PI * a2 * NdotH2 * NdotH2 + 0.001)) * exp((NdotH2 - 1.0f) / ( a2 * NdotH2)));///(1.f+roughness);
}

half F_Get(half f0, half HdotV)
{
    return (f0 + (1.0 - f0) * pow((1.0 - HdotV), 5));
}

half G_Get(half NdotV, half NdotL, half LdotV, half NdotH,half VdotH)
{
	return min(1.0f, min((2.0f * NdotH * NdotV)/VdotH, (2.0f * NdotH * NdotL)/ VdotH));
}

half GetSpecular(half4 matparam,half NdotH,half NdotV,half NdotL,half VdotL,half HdotV)
{
	matparam.x = lerp(PARAM_LIGHTING_ROUGHNESS_MIN, PARAM_LIGHTING_ROUGHNESS_MAX, matparam.x);
	half D = D_Get(matparam.x, NdotH);
	half G = G_Get(NdotV,NdotL,VdotL,NdotH,HdotV);
	half3 F = F_Get(matparam.y, HdotV)*saturate(matparam.y*3);
	return ((D*G*F)/(PI*NdotL*NdotV+0.001));
}

//#############################################################################

PSO_Lbuffer main(VSO_ResPos IN)
{
	PSO_Lbuffer OUT;

	half4 vNormals = tex2D(g_sNormals, IN.vTexUV);
	
	[branch]if(EQUAL_LAYER(vNormals.w, MTLTYPE_LAYER_OPAQUE_UNLIT) || EQUAL_LAYER(vNormals.w, MTLTYPE_LAYER_TRANSPARENT_UNLIT))
	{
		OUT.vAmdient.xyz = 0;
		OUT.vAmdient.w = 0;
		OUT.vSpecular = 0;
		return OUT;
	}
	
	half fDepth = tex2D(g_sDepth,IN.vTexUV).r;
	
	#ifdef IS_SHADOWED
	half fShadow = saturate(tex2D(g_sShadow, IN.vTexUV).r);
	half fOriginShadow = fShadow;
	#endif
	
	half4 vPosition = half4(g_vViewPos.xyz + IN.vWorldRay * fDepth, 1.0);
	half fDistance = distance(vPosition.xyz, g_vLightPos.xyz);
			
	half fInvDistance = 1.f - (fDistance/g_vLightPowerDist.y);
	
	[branch]if(fInvDistance < 0.0)
		fInvDistance = 0.0;
	
	half fAttenuation = fInvDistance*fInvDistance;
	
	half4 vParam = tex2D(g_sParameters, IN.vTexUV);
	
	half3 vNormalPixel = normalize(NormalDecode(vNormals.xy));
	half3 vLigth  = normalize(g_vLightPos.xyz - vPosition.xyz); 
	half3 vVertexToEye = normalize(g_vViewPos.xyz - vPosition.xyz);
	half3 vHalfVector = normalize(vVertexToEye + vLigth.xyz);
	
	half fNdotH = dot(vNormalPixel, vHalfVector);
	half fNdotV = dot(vNormalPixel, vVertexToEye);
	half fNdotL = dot(vNormalPixel, vLigth);
	half fLdotV = dot(vLigth, vVertexToEye);
	half fHdotV = dot(vHalfVector, vVertexToEye); 

	half fSpecular = GetSpecular(vParam, fNdotH, fNdotV, fNdotL, fLdotV, fHdotV);

	half fAbsDiffuse = saturate(fNdotL);
	half fMdiffuse = saturate(fNdotL * 0.5 + 0.5);
	half fDiffuse = fAbsDiffuse;
	
	//закрываем баг с отставанием теней
	#ifdef IS_SHADOWED
	fShadow = saturate(min(fShadow, fAbsDiffuse - 0.02));// + (vNormals.w == 1 ? 0.2 : 0));//+0.01;
	fAbsDiffuse = fShadow;
	#endif

	fDiffuse = saturate(fDiffuse + 0.1);
	fDiffuse = lerp(1, fDiffuse, vParam.z);
	
	#ifdef IS_SHADOWED
	//если просвечиваемость меньше 1 (значит пиксель просвечиваемый)
	[branch]if(vParam.z < 1.0)
		fDiffuse *= max(fOriginShadow, 0.2);
	else
		//иначе выбираем значения тени из диапазона, на основании силы света
		fDiffuse *= max(fShadow, lerp(0.01, 0.07, g_vLightColor.w));
	#endif
	
	OUT.vAmdient.xyz = g_vLightColor.xyz * g_vLightColor.xyz * g_vLightPowerDist.x * fAttenuation;
	OUT.vAmdient.w = fDiffuse * fMdiffuse * vParam.w * g_vLightPowerDist.x * fAttenuation;
	
	OUT.vSpecular = fSpecular * fAbsDiffuse * fAttenuation * g_vLightPowerDist.x;
	
	return OUT;
}