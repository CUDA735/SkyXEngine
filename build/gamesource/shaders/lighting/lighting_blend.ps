
/*
lighting_blend.ps
Cмешивание всех текстур для финального изображения
*/

#include <../struct.h>

//##########################################################################

sampler2D g_sColor:register(s0);
sampler2D g_sAmbient:register(s1);
sampler2D g_sSpecDiff:register(s2);
sampler2D g_sNormals:register(s3);
sampler2D g_sAdaptedLum:register(s4);
sampler2D g_sParameters:register(s5);

//##########################################################################

half4 main(VSO_PP IN):COLOR0
{
	half4 vNormal = tex2D(g_sNormals,IN.vTexUV);
	half fSort = vNormal.w;
	half fLayer = vNormal.z;
	
	//цвет приводим к sRGB
	half4 vColor = pow(tex2D(g_sColor,IN.vTexUV), 2.2);
	half4 vParameters = tex2D(g_sParameters,IN.vTexUV);

	half4 vAmbient = tex2D(g_sAmbient,IN.vTexUV);
	
	/* расчет фонового цвета
	1) интерполяция от чернобелого до цветного, на основании затенения, то есть чем больше тень тем меньше там фонового цвета
	*/
	half3 vAmbientColor = lerp((vAmbient.x + vAmbient.y + vAmbient.z)/3.0, vAmbient.xyz, vAmbient.w*2);
	
	/* 2) интерполяция приема цвета материалом, чем больше отражательная способность (f0) тем меньше примет цвета материал*/
	vAmbientColor = lerp(vAmbientColor.xyz, 1.0, clamp(vParameters.y, F0_MIN_4_DEST_AMBIENT, vParameters.y));
	
	half fSpecular = tex2D(g_sSpecDiff,IN.vTexUV).r;
	half fAdaptedLum = tex2D(g_sAdaptedLum, g_vTexUVcenter);

	// если материал освещаемый то надо вычислить его освещенность
	if(!(EQUAL_LAYER(fSort, MTLTYPE_LAYER_OPAQUE_UNLIT) || EQUAL_LAYER(fSort, MTLTYPE_LAYER_TRANSPARENT_UNLIT)))
		vColor.xyz = (vAmbientColor * vAmbient.w*vColor.xyz) + (fSpecular * 0.5 * vAmbient.xyz);
		
	// если слой материала относится к непрозрачной геометрии, тогда не нужна прозрачность
	if(int(fLayer * LAYERS_COUNT_MAX) == LAYER_OPAQUE)
		vColor.a = 1.0;

	//применение тонмапинга
	vColor.rgb *= TONE_MAPPING_DENOMENATOR/(fAdaptedLum + TONE_MAPPING_ADAPT_ADD_BIAS);
	vColor.rgb /= (fAdaptedLum + vColor.rgb);
	
	//приводим цвет к линейному пространству
	return pow(vColor, 1.0/2.2);
}