
/*
mtrlgeom_water.ps
Рендер воды (геометрии)
*/
 
#include <../struct.h>
#include <../mtrl.h>

half2 WinSize;
half4 Param;		
//x - коэфициент смещения текстурных координат 
//y - коэфициент прозрачности
//z - коэфициент микрорельефа
//w - коэфициент смешивания между отражением и основной текстурой (чем больше тем больше будет преобладать цвет основной текстуры, чем меньше тем больше будет преобладать цвет отражения)


half4 NearFarIsUnlit;		//ближняя и дальнияя плоскости отсечения

sampler2D BaseTex:register(s0);		//основная текстура
sampler2D NormalTex:register(s6);	//карта нормалей
sampler2D ParamTex:register(s10);	//параметры для освещения
sampler2D DepthTex:register(s14);	//карта глубины

ps_out_ds_mrt main(vs_out_water IN)
{
	ClipFar(IN.Pos.z,NearFarIsUnlit.y);
	
	ps_out_ds_mrt OUT;
	half Depth = IN.Pos.z;
	half3 normal1 = 2.0f * tex2D(NormalTex, IN.Tex2.xy) - 1.0f;
	half3 normal2 = 2.0f * tex2D(NormalTex, IN.Tex3.xy*0.5) - 1.0f;
	normal1.z = IN.Normal.z;
	normal2.z = IN.Normal.z;
	normal1 *= Param.z;
	normal2 *= Param.z;
	half3 normal = normalize((normal1+normal2+IN.Normal));

	half4 tmppsposnontr = mul(IN.Pos,MatrixRefraction);
	half depth = tex2D(DepthTex, tmppsposnontr.xy/tmppsposnontr.w + half2(0.5/WinSize.x,0.5/WinSize.y)).r;
	half intens = saturate(abs(((Depth/NearFarIsUnlit.y) - depth)*NearFarIsUnlit.y) / (Param.y * 100.f));

	half4 colorbase = tex2D(BaseTex, IN.TexUV);

	OUT.Color = colorbase;
	OUT.Color.a = intens;
	
	OUT.Normal.xyz = 0.5f * normal + 0.5;
	OUT.Normal.w = NearFarIsUnlit.z;
	
	OUT.Param = tex2D(ParamTex,IN.TexUV);
	OUT.Param.w = NearFarIsUnlit.w;
	
	OUT.Depth = GetDepthW(IN.Pos,NearFarIsUnlit.xy);
	
	return OUT;
}