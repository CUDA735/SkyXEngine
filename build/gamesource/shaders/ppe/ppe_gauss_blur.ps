
/*
ppe_gauss_blur.ps
Размытие по Гауссу. Если указано макроопределение _H_ то будет размытие по горизонтали, иначе по вертикали.
*/

#include <../struct.h>

half2	SizeMap;

sampler2D BaseSampler:register(s0);

half CoefBlur;

half4 main(vs_out_pp IN) : COLOR0
{
	half2 tx  = IN.TexUV;
	
	#ifdef _H_
    half2 dx  = half2(0.f,1.f/SizeMap.y)*CoefBlur;
	#else
    half2 dx  = half2(1.f/SizeMap.x,0.f)*CoefBlur;
	#endif
	
	half2 sdx = dx;
	
    half4 color = tex2D(BaseSampler,tx) * 0.134598f;
	//half alpha = color.a;
    color += (tex2D(BaseSampler,tx+sdx) + tex2D(BaseSampler,tx-sdx))*0.127325f;
    sdx += dx;
    color += (tex2D(BaseSampler,tx+sdx) + tex2D(BaseSampler,tx-sdx))*0.107778f;
    sdx += dx;
    color += (tex2D(BaseSampler,tx+sdx) + tex2D(BaseSampler,tx-sdx))*0.081638f;
    sdx += dx;
    color += (tex2D(BaseSampler,tx+sdx) + tex2D(BaseSampler,tx-sdx))*0.055335f;
    sdx += dx;
    color += (tex2D(BaseSampler,tx+sdx) + tex2D(BaseSampler,tx-sdx))*0.033562f;
    sdx += dx;
    color += (tex2D(BaseSampler,tx+sdx) + tex2D(BaseSampler,tx-sdx))*0.018216f;
    sdx += dx;
    color += (tex2D(BaseSampler,tx+sdx) + tex2D(BaseSampler,tx-sdx))*0.008847f;
    sdx += dx;
	
	return color;
}