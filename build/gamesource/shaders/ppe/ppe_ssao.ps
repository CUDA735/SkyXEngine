
/*
ppe_ssao.ps
Просчет ssao с учетом нормалей, на выходе зернистая карта затенения
*/

#include <../struct.h>
#include <../mtrl.h>

sampler2D DepthSampler:register(s0);
sampler2D NormalSampler:register(s1);
sampler2D RndSampler:register(s2);

half4 Params;
//x - радиус
//y - минимально допустимая разница в глубине между пикселя для просчета затенения
//z - освещенность пикселя по дефолту (если разница меньше минимальной)
//w - допустимая разница для сравнения

half2 NearFar;
half2 Ratio;
half3 ViewPos;
half4x4 ViewProj;

half3 ArrRndVecSSAO[24];

#if defined(SSAO_Q_3)
static int NumSam = 24;
#elif defined(SSAO_Q_2)
static int NumSam = 16;
#else
static int NumSam = 8;
#endif

half4 main(vs_out_res_pos IN):COLOR0
{
	half depth = tex2D(DepthSampler, IN.TexUV).r;
	
	[branch]if(depth >= 1.f)
		return 1.f;
	
	half3 position = half3(ViewPos + (IN.WorldRay) * (depth));
	half3 normal = normalize(2.f * tex2D(NormalSampler, IN.TexUV).rgb - 1.f);
	half3 random = normalize(2.f * tex2D(RndSampler, IN.TexUV*Ratio*96.f).rgb - 1.f);

	half occlusion = 0.f;
		for(int i=0; i < NumSam; i++)
		{
			half3 ray = (reflect(ArrRndVecSSAO[i],random));
			half3 hemi_ray = ray * sign(dot(ray,normal));
			half4 newpos = half4(position + hemi_ray * Params.x,1);

			newpos = mul(newpos,ViewProj);
			newpos /= newpos.w;
			newpos.x = newpos.x * 0.5f + 0.5f;
			newpos.y = newpos.y * (-0.5f) + 0.5f;

			half newdepth = tex2D(DepthSampler, (newpos.xy)).r;
				[branch]if(newdepth >= 1.f)
					occlusion += 1.f;
			half difference = (newdepth - depth)*NearFar.y;
			
			half distanceCheck = min(Params.z, (Params.x/abs(difference)));
			[branch]if(abs(difference) < Params.y)
				occlusion += Params.z;
			else
				occlusion += 1-step(difference, Params.w)*distanceCheck;
		}
	occlusion = clamp(saturate(occlusion/NumSam)*1.2f,0.3f,1.f);
	occlusion *= occlusion;
	
	return half4(occlusion,occlusion,occlusion,1.f);
}