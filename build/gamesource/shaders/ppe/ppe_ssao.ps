
#include <../struct.h>

sampler2D DepthSampler:register(s0);
sampler2D NormalSampler:register(s1);
sampler2D RndSampler:register(s2);

half4 Params;
//x - радиус
//y - минимально допустимая разница в глубине между пикселя для просчета затенения
//z - освещенность пикселя по дефолту (если разница меньше минимальной)
//w - допустимая разница для сравнения
half2 NearFar;
half2 Ratio;
half3 ViewPos;
half4x4 ViewProj;

half3 ArrRndVecSSAO[24];

static int NumSam = 16;

half4 main(vs_out_res_pos IN):COLOR0
{
	half depth = tex2D(DepthSampler, IN.TexUV).r;
	
	if(depth >= 1.f)
		return 1;
	
	half3 position = half3(ViewPos + (IN.WorldRay) * (depth));
	half3 normal = normalize(2.f * tex2D(NormalSampler, IN.TexUV).rgb - 1.f);
	half3 random = normalize(2.f * tex2D(RndSampler, IN.TexUV*Ratio*96).rgb - 1.f);

	half occlusion = 0.0;
		for(int i=0; i < NumSam; i++)
		{
			half3 ray = (reflect(ArrRndVecSSAO[i],random));
			half3 hemi_ray = ray * sign(dot(ray,normal));
			half4 newpos = half4(position + hemi_ray * Params.x,1);

			newpos = mul(newpos,ViewProj);
			newpos /= newpos.w;
			newpos.x = newpos.x * 0.5 + 0.5;
			newpos.y = newpos.y * (-0.5) + 0.5;

			half newdepth = tex2D(DepthSampler, (newpos.xy)).r;
				if(newdepth >= 1.f)
					occlusion += 1;
			half difference = (newdepth - depth)*NearFar.y;
			
			half distanceCheck = min(Params.z, (Params.x/abs(difference)));
			if(abs(difference) < Params.y)
				occlusion += Params.z;
			else
				occlusion += 1-step(difference, Params.w)*distanceCheck;
		}
	occlusion = clamp(saturate(occlusion/NumSam)*1.2,0.3,1.f);
	//occlusion *= occlusion;
	
	return half4(occlusion,occlusion,occlusion,1.f);
}